#include "Game.h"

Game::Game(UINT width, UINT height) : Renderer(width,height) {}

Game::~Game() {}

void Game::OnInit() {
	Renderer::OnInit(); //Device initialized within this call
    CreateDescriptorHeaps();
	Player::OnInit(45.0f, WindowInterface::GetAspectRatio(), 0.1f, 100.0f);
    Terrain::Load();
    CD3DX12_CPU_DESCRIPTOR_HANDLE srvHandle(m_srvHeap->GetCPUDescriptorHandleForHeapStart());
    srvHandle.Offset(1, m_device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV));
    {
        CD3DX12_GPU_DESCRIPTOR_HANDLE srvGPU(m_srvHeap->GetGPUDescriptorHandleForHeapStart());
        srvGPU.Offset(1,m_device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV));
        m_lightDepthMapSRV = srvGPU;
    }

    ThrowIfFailed(LightPerspectiveDepthMap::Load(m_device.Get(),m_srvHeap->GetCPUDescriptorHandleForHeapStart(),m_rtvHeap->GetCPUDescriptorHandleForHeapStart(),m_dsvHeap->GetCPUDescriptorHandleForHeapStart(),srvHandle));
    //Lights::Load();
    m_time = std::chrono::high_resolution_clock::now();
}

void Game::OnUpdate() {
    std::chrono::time_point<std::chrono::high_resolution_clock> curr = std::chrono::high_resolution_clock::now();
    std::chrono::duration<float> diff = curr - m_time;
    float elapsedTime = diff.count();
    m_time = curr;
    Player::Move(elapsedTime);
    if (m_inputCaptured) {
        POINT cursorPos = {};
        GetCursorPos(&cursorPos);
        Player::Pitch(((cursorPos.y - m_cursorPos.y) / m_mouseScaleFactor) * elapsedTime);
        Player::RotateWorldY(((cursorPos.x - m_cursorPos.x) / m_mouseScaleFactor) * elapsedTime);
        SetCursorPos(m_cursorPos.x, m_cursorPos.y);
    }
    Renderer::SetCameraConstants(Player::GetCameraConstants());
    Scene::Update(elapsedTime, Player::GetPosition());
}

void Game::OnRender() {
    BasicRenderObject pObjects[] = { Terrain::GetRenderObject() };
    ResetCommandList();
    LightPerspectiveDepthMap::Draw(m_commandList.Get(), pObjects, 1);
    m_commandList->Close();
    FlushCommandList();

    ID3D12DescriptorHeap* ppHeaps[] = {m_srvHeap.Get()};
    Renderer::RenderWithRobustLight(pObjects, 1, m_lightDepthMapSRV, ppHeaps, GetCameras(), *(PointLight*)this);
    //Renderer::OnRender(pObjects, 1, Lights::GetView());
}

void Game::OnKeyDown(WPARAM wParam) {
    if (wParam == VK_ESCAPE) {
        if (m_inputCaptured) {
            m_inputCaptured = FALSE;
            SetCursor(m_hCursor);
        }
        else {
            m_inputCaptured = TRUE;
            SetCursor(NULL);
        }
        return;
    }
    if (m_inputCaptured) {
        Player::OnKeyDown(wParam);
    }
}

void Game::OnKeyUp(WPARAM wParam) {
    if (m_inputCaptured) {
        Player::OnKeyUp(wParam);
    }
}

void Game::SetCursorPoint(POINT p, HCURSOR hCursor) {
	m_cursorPos = p;
	m_mouseScaleFactor = 20.0f;
	m_hCursor = hCursor;
	SetCursor(m_hCursor);
}

void Game::OnDestroy() {
	Renderer::OnDestroy();
}

void Game::CreateDescriptorHeaps() {
    D3D12_DESCRIPTOR_HEAP_DESC heapDesc;

    {
        heapDesc = {
            D3D12_DESCRIPTOR_HEAP_TYPE_RTV,
            2, //Main render target, as well as a render target for the light perspective depth maps
            D3D12_DESCRIPTOR_HEAP_FLAG_NONE,
            0
        };

        ThrowIfFailed(m_device->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&m_rtvHeap)));
    }

    {
        heapDesc = {
            D3D12_DESCRIPTOR_HEAP_TYPE_DSV,
            2, //Main render target, as well as a render target for the light perspective depth maps
            D3D12_DESCRIPTOR_HEAP_FLAG_NONE,
            0
        };

        ThrowIfFailed(m_device->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&m_dsvHeap)));
    }

    {
        heapDesc = {
            D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
            2, //First handle points to the camera matrices in the light perspective depth mapping. Second points to the SRV for the cubemaps generated by that process.
            D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE,
            0
        };

        ThrowIfFailed(m_device->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&m_srvHeap)));
    }
}